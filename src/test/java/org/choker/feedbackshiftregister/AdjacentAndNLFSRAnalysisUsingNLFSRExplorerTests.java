package org.choker.feedbackshiftregister;

import org.junit.jupiter.api.Test;

/**
 * Analysis of LC & NLC (if applicable) of maximal and non-maximal Adjacent-AND NLFSR.
 * The NLFSRs are generated using AdjacentAndNlfsrExplorer API.
 *
 * Copyright (c) 2024 Jalal Choker
 */
public class AdjacentAndNLFSRAnalysisUsingNLFSRExplorerTests {
	@Test
	void testNLFSRComplexity() {
		//used in demo
		testNLFSRComplexity(6, true);
	}

	private static void testNLFSRComplexity(int nlfsrLn, boolean maximal) {
		System.out.println("\n"
				+ "#".repeat(3)
				+ " Find P, LC and NLC of sequences generated by Adjacent-AND NLFSR test "
				+ "#".repeat(3));

		System.out.print("Generating all " + (maximal ? "maximal" : "non-maximal")
				+ " Adjacent-AND NLFSRs for n=" + nlfsrLn + " using NLFSR Explorer...");
		var nlfsrs = AdjacentAndNLFSRExplorer.findAll(nlfsrLn, maximal);
		System.out.println("found " + nlfsrs.size() + " NLFSRs");

		System.out.println("Calculating LC and NLC of the NLFSRs...");
		Integer pMin = Integer.MAX_VALUE, pMax = 0, lcMin = Integer.MAX_VALUE, lcMax = 0;
		for (var nlfsr : nlfsrs) {
			var result = analyseNLFSR(nlfsr);
			// notice the successful state used to find the NLFSR
			System.out.println("NLFSR -> " + nlfsr + ", P=" + result[0] + ", LC=" + result[1]
					+ (maximal ? "" : ", NLC=") + (maximal ? "" : result[2]));

			if (pMin > result[0])
				pMin = result[0];
			if (pMax < result[0])
				pMax = result[0];
			if (lcMin > result[1])
				lcMin = result[1];
			if (lcMax < result[1])
				lcMax = result[1];
		}

		System.out.println("\n(n = " + nlfsrLn + ", Maximal-length: " + (maximal ? "Yes" : "No")
				+ ") --> Total " + nlfsrs.size() + ", P(Min) " + pMin + ", P(Max) " + pMax
				+ ", LC(Min) " + lcMin + ", LC(Max) " + lcMax);
	}

	private static final int SOE_MAX_N = 11; // maximum FSR size that can be used in SoE/ESoE before time-out (using onlinegdb.com environment)

	// returns an array of 3 elements: P, LC(using BM algo.), NLC(using extended SoE) of the Fibonacci NLFSR
	private static int[] analyseNLFSR(FibonacciNLFSR nlfsr) {
		var complexity = new int[3];

		complexity[0] = nlfsr.getPeriod().intValue();

		var twoPeriods = nlfsr.generate(2 * nlfsr.getPeriod().intValue()); // generate 2P
		var twoPeriodsArray = Utils.toIntArray(twoPeriods);

		var lc = BerlekampMassey.run(twoPeriodsArray).size();
		complexity[1] = lc;

		var n = nlfsr.getLength();
		if ((!nlfsr.isMaximal()) && n <= SOE_MAX_N) {
			// generate 2 periods from all possible states until an equivalent Adjacent-AND NLFSR is found
			int nlc = 0;
			for (var s = 1; s < (1 << n); s++) {
				var strS = Integer.toBinaryString(s);

				nlfsr.setState(strS); // update state
				twoPeriods = nlfsr.generate(2 * nlfsr.getPeriod().intValue()); // generate 2 periods
				twoPeriodsArray = Utils.toIntArray(twoPeriods);
				var recoveredNlfsr = NLFSRFinder.find(twoPeriodsArray); // try find NLFSR
				nlc = recoveredNlfsr.get("cv").size();
				if (nlc != 0) {
					complexity[2] = nlc;
					break; // stop looping when an NLFSR is found
				}
			}
		}

		return complexity;
	}
}