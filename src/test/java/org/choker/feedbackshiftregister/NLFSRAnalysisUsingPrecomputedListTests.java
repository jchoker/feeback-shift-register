package org.choker.feedbackshiftregister;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
/**
 * Analysis of LC and NLC where applicable for Adjacent-AND and generic NLFSRs using
 * precomputed files of maximal feedback functions. 
 * Files source: https://people.kth.se/~dubrova/nlfsr.html
 * 
 * Copyright (c) 2024 Jalal Choker
*/
public class NLFSRAnalysisUsingPrecomputedListTests {

  @DisplayName("Analysis - Dubrova Maximal Generic NLFSRs")
  @Test
  void testNLFSRComplexity() {
    // used in demo
    testNLFSRComplexity(10, "Maximal Generic NLFSR/10NLFSR.txt", "0001", true);

    // used in demo
    //testNLFSRComplexity(6, "6NLFSR.txt", "0001", false);
  }

  private static void testNLFSRComplexity(
          int n, String fileName, String state, boolean adjacentAND) {
    System.out.println("\n"
            + "#".repeat(3) + "Analysis of the LC and NLC of sequences generated by maximal NLFSRs "
            + "#".repeat(3) + "\n");
    List<String> functions = Utils.readTextFile(fileName);
    var complexities = new HashMap<String, int[]>();

    Integer lcMin = Integer.MAX_VALUE, lcMax = 0;
    for (var f : functions) {
      var complexity = getLcAndNlc(n, f, state, adjacentAND);
      if (complexity != null) {
        complexities.put(f, complexity);
        var lc = complexity[0];
        if (lcMin > lc)
          lcMin = lc;
        if (lcMax < lc)
          lcMax = lc;
      }
    }
    System.out.print("n: " + n + ", total: " + complexities.size() + ", Adjacent-AND: " + adjacentAND
            + ", LC(Min) " + lcMin + ", LC(Max) " + lcMax + "\n");
    complexities.forEach(
            (key, value)
                    -> System.out.println("f=" + key + ": LC=" + value[0] + (adjacentAND ? "" : ", NLC=" + value[1])));
  }

  // maximum fsr size that can be used in SoE before time-out (using onlinegdb.com)
  private static final int SOE_MAX_N = 9;

  // returns an array of 2 elements: LC using BM and NLC using extended SoE respectively
  private static int[] getLcAndNlc(
          int n, String representation, String state, boolean adjacentAND) {
    var complexity = new int[2];

    var taps = Utils.extractTaps(representation);
    var ands = Utils.extractAnds(representation);

    if (Utils.isAdjacentAndNLFSR(ands) != adjacentAND)
      return null;

    var nlfsr = new FibonacciNLFSR(n, taps, ands, state);
    var twoPeriods = nlfsr.generate(2 * nlfsr.getPeriod().intValue());
    var twoPeriodsArray = Utils.toIntArray(twoPeriods);

    // after n = 16 BerlekampMassey algo becomes unresponsive
    var lc = BerlekampMassey.run(twoPeriodsArray).size();
    complexity[0] = lc;

    if (n <= SOE_MAX_N) {
      int nlc = 0;
      for (var s = 1; s < (1 << 3);
           s++) // generate 2 periods from all possible states until NLC is found
      {
        var strS = Integer.toBinaryString(s);
        var fixedWidthStrState = "0".repeat(n - strS.length()) + strS;
        nlfsr = new FibonacciNLFSR(n, taps, ands, strS);
        twoPeriods = nlfsr.generate(2 * nlfsr.getPeriod().intValue()); // generate 2 periods
        twoPeriodsArray = Utils.toIntArray(twoPeriods);
        // noticable performance degradation for n = 8, no response using SoE/eSoE for n = 9
        var recoveredNlfsr = NLFSRFinder.find(twoPeriodsArray);
        var cv_nlfsr = recoveredNlfsr.getOrDefault("cv", new ArrayList<Integer>());
        nlc = cv_nlfsr.size();
        if (nlc != 0) {
          complexity[1] = nlc;
          break;
        }
      }
    }

    return complexity;
  }
}
